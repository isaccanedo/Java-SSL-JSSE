# Java-SSL-JSSE
:key: # Uma Implementação SSL utilizando JSSE

### Introdução
Quaisquer informações transmitidas em redes de computadores, ou na Internet, está suscetível à intercepção por outros não autorizados. Algumas informações podem ser sensíveis, como número de cartão de crédito e outras informações pessoais. Para tornar a Internet mais útil para empresas e mais segura para o comércio eletrônico, aplicações devem proteger as informações de seus usuários, utilizando encriptação, autenticação e protocolos seguros de comunicação. O secure Hypertext Transfer Protocol (HTTPs), que é o HTTP sobre o Secure Socket Layer (SSL), é usado com sucesso em aplicações de comércio eletrônico.

### O protocolo SSL
O protocolo SSL, que foi desenvolvido pela Netscape em 1994, permite aos clientes (normalmente os navegadores Web) e servidores HTTP comunicarem-se sobre uma conexão segura. O SSL oferece encriptação, autenticação e integridade dos dados no intuito de proteger a informação trocada em redes públicas inseguras. Há várias versões do SSL: SSL 2.0 possui algumas fraquezas de segurança, não sendo muito utilizado atualmente; já o SSL 3.0 é universalmente suportado; e finalmente o Tranport Layer Security (TLS), que é um melhoramento do SSL 3.0, tem sido adotado como um padrão na Internet e amplamente suportado por quase todos os softwares recentes.
A encriptação protege dados contra uso não autorizado, utilizando algoritmos criptográficos, antes da transmissão. O dado é criptografado em um lado (cliente ou servidor), transmitido, decifrado pelo outro lado e, então, processado.

A autenticação é um método para verificar a indentidade do remetente. A primeira vez que um navegador Web ou outro cliente tenta se comunicar com um servidor Web sobre uma conexão segura, o servidor apresenta ao cliente um conjunto de credenciais na forma de um certificado.

Certificados são emitidos e validados por autoridades confiáveis conhecidas como Autoridades Certificadoras (CAs). Um certificado representa a identidade da chave pública de uma pessoa. É um documento assinado que tem por finalidade dizer: "Eu certifico que a cheve pública presente neste documento pertence a entidade nomeada neste documento. Assinado CA". Algumas CAs bastante conhecidas são a Verisign e Entrust. Vale ressaltar que os certificados utilizados com SSL/TLS são certificados X.509.

A integridade de dados refere-se a uma maneira de assegurar que os dados não foram modificados durante a tranmissão

### SSL e a pilha de protocolos TCP/IP
Como o próprio nome indica (Camada de Socket Seguro), conexões SSL agem como sockets conectados por TCP. Portanto, podemos pensar as conexões SSL como conexões TCP seguras desde que o lugar do SSL na pilha de protocolos é imediatamente acima do TCP e logo abaixo da camada de aplicação, como mostra a figura 1. Deve-se ressaltar, entretanto, que o SSL não suporta algumas das habilidades do TCP como dados out-of-band.

O protocolo SSL possui duas camadas: "SSL Record Protocol", que é responsável por encapsular outros protocolos de alto nível e a "SSL Handshake Protocol", que recebe os dados a serem codificados/decodificados. Esta segunda camada é responsável pela autenticação do cliente e/ou servidor, negociação do algoritmo criptográfico e suas chaves antes da aplicação receber ou enviar qualquer dado.

### Negociação da Encriptação (Handshake)
Dentre as "facilidades" do SSL que o tornaram o veículo padrão para trnasações seguras de comércio eletrônico é o seu suporte para a negociação da encriptação e dos algoritmos de autenticação. Os projetistas do SSL pereceberma que nem todas as partes envolvidas usam o mesmo software cliente e que, conseqüentemente, nem todos os clientes incluem um algortimo criptográfico em particular. O mesmo vale para os servidores. O cliente e os servidores dos dois lados de uma conexão devem, então, ser capazes de negociar os algoritmos de encriptação e decriptação ("cipher suites") durante o handshake inicial. Se eles não tiverem algoritmos suficientes em comum, o handshake deve ser interrompido e a tentativa de conexão irá falhar.

O protocolo SSL permite que tanto o cliente quanto o servidor autentiquem um ao outro, mas, tipicamente, somente o servidor é autenticado na camada SSL. Clientes são, costumeiramente, autenticados na camada de aplicação, por meio de uso de passwords enviados sobre um canal protegido por SSL. Esse padrão é comum em transações bancárias, dentre outras aplicações Web seguras.

Os parâmetros criptográficos do estado de uma sessão são produzidos pelo Handshake do protocolo SSL, que opera no topo da camada Record Layer do SSL. Quando um cliente SSL e um servidor SSL iniciam a comunicação, eles concordam em uma versão do protocolo, escolhem os algortimos criptográficos, autenticam um ao outro (opcionalmente) e usam criptografia de chave pública para gerar os segredos que compartilham. Esses passos são realizados pelo protocolo handshake, que pode ser resumido como segue:

- O cliente envia uma hello message para a qual o servidor deve responder com uma outra hello message, caso contrário um erro fatal ocorrerá e a conexão falhará. O hello do cliente e o do servidor são usados para estabelecer capacidades de segurança entre o cliente e o servidor.
- Esses hello's estabelecem os seguintes atributos: versão do protocolo, identificação da sessão, suite de cifras e métodos de compressão. Adicionalmente, dois valores randômicos são gerados e trocados: ClentHello.random e ServerHello.random.
- A seguir, o servidor enviará o seu certificado, se este for autenticado. Adicionalmente, uma mensagem de trocas de chave do servidor pode ser enviada, se necessário (por exemplo, se o servidor não possuir certificado ou se o seu certificado for apenas para assinatura). Se o servidor está autenticado, ele pode solicitar um certificado do cliente.
- Agora o servidor enviará uma mensagem hello done, indicando que a fase hello message do handshake está completa. O servidor irá, então, esperar por uma resposta do cliente.
- Se o servidor tiver enviado uma mensagem de solicitação de certificado, o cliente deve o seu certificado ou uma mensagem de alerta de que não há certificado (no_certificate alert). A mensagem de troca de chaves do cliente é, então, enviada, e o conteúdo desta mensagem dependerá do algortimo assimétrico escolhido durante o hello do cliente e o hello do servidor. Se o cliente enviou um certificado com possibilidade de assinatura, uma mensagem de verificação digital do certificado (digitally-signed cerfiticate verify message) é enviada para verificar, explicitamente, o certificado.
- Nesse momento, uma mensagem de mudança de especificação da cifra é enviada pelo cliente, e o cliente copia a Especificação de Cifra (Cipher Spec) da cifra pendente na Especificação atual. O cliente envia, então, imediatamente a mensagem de finalização, juntamente com os novos algoritmos, chaves e segredos.
- Em resposta, o servidor enviará sua mensagem de mudança de Cipher Spec, tranferindo a cifra pendente para a Especificação atual e envia sua mensagem de finalização juntamente com a nova Cipher Spec.

### JSSE
O Java Secure Socket Extension (JSSE), um conjunto de pacotes que habilita comunicação segura na Internet, é um framework que implementa, totalmente em Java, o Secure Soket Layer. Esses pacotes habilitam a construção de aplicações de rede seguras; isso possibilita a passagem, de forma segura e confiável, de dados entre um cliente e um servidor executando qualquer protocolo, como HTTP, FTP, Telnet, entre outros.

Além disso, o JSSE abstrai a complexidade inerente a certos algortimos criptográficos e, portanto, minimiza o risco de criação de vulnerabilidades. Como veremos, o JSSE torna o desenvolvimento de aplicações habilitadas com SSL bastante simples, nos permitindo integrar o SSL de forma fácil. O framework JSSE é capaz de suportar muitos protocolos de comunicação segura como SSL 2.0 e 3.0 e TLS 1.0.

### Programando com JSSE
As APIS JSSE complementam os pacotes java.security e java.net, provendo classes que implementam sockets de rede, gerenciadores de chaves e um framework que funciona como uma fábrica para o encapsulamento do comportamento de sockets. Essas classes estão incluídas nos pacotes javax.net e javax.net.ssl. O principal pacote para a criação de sockets seguros baseados em SSL é o javax.net.ssl. A seguir, há uma breve descrição de algumas das classes e interfaces desse pacote.

- Interface KeyManager
Essa interface é a base para os gerenciadores de chave JSSE. Os gerenciadores de chave são responsáveis pelo material (as chaves) que é usado para autenticar o socket SSL junto ao seu par (isto é, autenticar o servidor junto ao cliente e/ou autenticar o cliente junto ao servidor). Se nenhuma chave estiver disponível o socket não terá a capacidade de se autenticar. KeyManagers são criados ou usando um KeyManagerFactory ou por meio de uma de suas subclasses.
- Interface SSLSession
Essa interface implementa as sessões SSL, que são usadas para descrever a relação atual entre duas entidades. Cada conexão SSL envolve uma sessão por vez. Sessões são criadas como parte do protocolo de handshake do SSL. Esta interface permite que sejam conhecidas as cifras que estão sendo utilizadas na sessão (por meio do método getCipherSuite()), o ID da sessão (getId()), o protocolo em uso (getProtocol()), os certificados que foram definidos como parte da definição da sessão (getPeerCertificates()), dentre outras características.
- Classe HandshakeCompletedEvent
Essa classe implementa um evento que indica que o handshake SSL está completo para uma dada conexão SSL. Todas as informações do resultado do handshake são capturadas por meio de um objeto do tipo SSLSession.
- Classe KeyManagerFactory
Essa classe funciona como uma "fábrica" de gerenciadores de chaves, baseada em uma fonte das chaves. Cada gerenciador de chaves gerencia um tipo específico de material para as chaves que serão usadas por um socket seguro. O material da chave é baseado em um KeyStore e/ou em um provedor específico. Os métodos comumente utilizados são o init(KeyStore ks, char[] password), onde é inicializado um KeyManagerFactory para trabalhar com um KeyStore específico e o método getKeyManagers() que retorna um gerenciador para cada tipo de material de chave.
- Classe SSLContext
Instâncias dessa classe representam uma implementação segura de sockets que age como uma fábrica para a construção de sockets seguros. Em outras palavras, um SSLContext é um ambiente para a implementação do JSSE. Podem ser criados por meio do seu método estático getInstance(String protocol), onde se informa um protocolo (por exemplo, SSLv3) para que se obtenha um SSLContext. Essa classe é inicializada por meio do método init(KeyManager[] km, TrustManager[] tm, SecureRandom random).
- Classe SSLSocket
Essa classe estende a classe Socket do pacote javax.net e provê sockets seguros por meio de uso de protocolos como o SSL ou o TLS. Alguns métodos importantes são: getEnabledCipherSuites() que retorna o nome das cifras SSL que estão habilitadas para uso na conexão atual, getSession() que retorna a sessão SSL em uso na conexão atual, setWantClientAuth(boolean auth) que configura o socket para solicitar a autenticação do cliente, startHandshake() que inicia um handshake SSL para a conexão atual, dentre outros.
- Classe SSLServerSocket
Essa classe estende a classe ServerSocket do pacote javax.net e provê sockets de servidores seguros por meio de uso de protocolos como o SSL ou o TLS. Intâncias dessas classes podem ser criadas por meio de um SSLServerSocketFactory. A função primária de um SSLServerSocket é criar sockets SSL aceitando conexões (por meio do método accept()). Alguns métodos importantes são: getEnabledCipherSuites() que retorna o nome das cifras SSL que estão habilitadas para uso na conexão atual, getSession() que retorna a sessão SSL em uso na conexão atual, setNeedClientAuth(boolean auth) que controla se as conexões aceitas pelo servidor devem incluir autenticação por parte do cliente, dentre outros.
- Classe TrustManagerFactory
Esta classe age como uma fábrica para a criação de gerenciadores confiáveis (TrustManagers). Um gerenciador confiável gerencia um tipo específico de material para serem usados por sockets seguros. Esse material é baseado em fonte de Keystores e/ou provedores específicos. Alguns métodos importantes são getTrustManager() que retorna objetos do tipo TrustManager e init(KeyStore ks) que inicializa um TrustManagerFactory por meio de um KeyStore.
